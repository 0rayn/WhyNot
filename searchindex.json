[{"content":"I - Beyond the Basics: In My Last Post, we covered the essentials: flashing OpenWrt, setting up serial access, and using a USB drive to give the TL-MR3020 some actual storage breathing room . We successfully turned a travel router into a functional, headless Linux server.\nBut let‚Äôs be honest‚Ä¶ a headless server is boring.\nI didn\u0026rsquo;t just want a box that blinks in the corner. I wanted a computer. I wanted a display, I wanted to type, and I wanted to interact with the physical world. The problem? The TL-MR3020 has no video output, no sound, and extremely limited GPIO.\nSo, I decided to build a distributed system where the router acts as the central controller, orchestrating a network of specialized devices to overcome its own hardware limitations.\nII - The Architecture: Instead of forcing the router to do tasks it wasn\u0026rsquo;t designed for (like generating video signals), I built a system where every component has a specific job. The architecture transforms the router into a central hub connecting three distinct modules :\n1- The Core (TL-MR3020): Runs the OS (OpenWrt) and manages the system logic.\n2- The Graphics (ESP32): Drives a VGA monitor via a TCP/IP connection.\n3- The I/O controller (Arduino Nano): Handles physical sensors and actuators, while communicating with the Tl-MR3020 via serial.\n4- The input (USB Keyboard): Provides the user interface.\nIII - The \u0026ldquo;Graphics Card\u0026rdquo;: ESP32 \u0026amp; VGA This was the biggest technical hurdle. Generating a VGA signal requires precise, microsecond-timing that a Linux router simply cannot handle without crashing or freezing.\nThe solution? Outsource the rendering. I used an ESP32 running a custom firmware I wrote called ESP-VGA-Displayer. It acts as a dedicated GPU that listens for commands over the network.\nThe Protocol: The ESP32 opens a TCP server on port 1337 (naturally). The router‚Äîor any device on the network‚Äîcan send simple newline-terminated text commands to control the screen.\nIt‚Äôs incredibly simple to use. I can even test it manually using netcat from my laptop:\nnc \u0026lt;ESP_IP\u0026gt; 1337 /clear /color red /print System Failure! Under the Hood: For the actual rendering, I used the ESP32Lib library by bitluni. Thanks to my background developing a 32-bit Kernel, I was already familiar with how VGA signal generation works, which made bitluni\u0026rsquo;s library very intuitive to implement. It handles the heavy lifting of signal timing, while my code handles the TCP command parsing and text layout.\nSupported Commands:\n/clear ‚Äì Wipes the screen. /print [text] ‚Äì Displays text on the monitor. /color [name] ‚Äì Changes text color (supports black, blue, green, red, etc.). This architecture means the router doesn\u0026rsquo;t need to know how to draw pixels‚Äîit just sends text strings like \u0026ldquo;Hello World\u0026rdquo; and the ESP32 handles the rest.\nIV - The I/O Expansion: Arduino Nano Routers are great at networking, but terrible at interacting with hardware sensors. They simply lack the exposed pins.\nTo fix this, I integrated an Arduino Nano running my custom 3020-NANO firmware. It connects to the router via Serial (9600 baud) and listens for simple text commands. This effectively gives the router full GPIO control.\nThe Protocol: I designed a human-readable protocol so I can test it manually or script it easily.\nBasic I/O: pinmode 13 output, write 13 high, read 13. LCD Control: It even supports I¬≤C LCD screens. exec lcd init 0x27 16 2 exec lcd write Hello World Now, if I want the router to display a status message or blink an alert LED, it just sends a string to the Nano, and the Nano executes the hardware operation.\nV - The Interface: Keyboard Integration: A computer isn\u0026rsquo;t complete without input, so I wanted to plug a standard USB keyboard into the router. But before I could write a single line of code, I hit a wall: Storage Space.\nThe TL-MR3020 has extremely limited internal flash memory. To make room for the USB HID (Human Interface Device) drivers needed for the keyboard, I had to rebuild my custom OpenWrt image again. I made the tough call to strip out the USB storage expansion utilities I used in the previous step to free up space for the keyboard drivers.\nOnce the OS could finally recognize the device, I wrote 3020-Keyboard, a C program that acts as the software glue between the hardware input and the network display.\nThe Input: It reads raw keystrokes directly from the Linux event subsystem (/dev/input/event0). The Output: It splits the signal in two directions: To the Display: It connects to the ESP32 via TCP and automatically wraps text in the /print command, so what I type appears instantly on the VGA screen. To the Hardware: It forwards commands to the Nano via the router\u0026rsquo;s internal serial port (/dev/ttyATH0). This setup allows for live text mirroring and creates a genuine terminal experience using nothing but e-waste components.\nVI - The Result: taraaaa ! After linking all the components and writing the software needed for them to function together, the system finally came to life .\nIt is no longer just a router. It is a live terminal and IoT Hub. I can type commands on a mechanical keyboard, see the output on a VGA monitor, and control physical hardware‚Äîall coordinated by that tiny white box we started with .\nVII - The Future The hardware is done. The drivers are written. Now comes the fun part: giving it a purpose.\nWhether it\u0026rsquo;s a smart home dashboard, a dedicated network traffic monitor, or a text-based adventure machine, the foundation is ready. This project proves that you don\u0026rsquo;t need the latest hardware to build something amazing‚Äîjust a bit of creativity and the willingness to void a warranty\u0026hellip; not like it got any warranty anyway hhhhhhhhhh\nCheck out the code: The 3020 Project GitHub ","date":"13 January, 2026","id":0,"permalink":"/WhyNot/posts/the-3020-project/","summary":"In My Last Post, we covered the essentials: flashing OpenWrt, setting up serial access, and using a USB drive to give the TL-MR3020 some actual storage breathing room . We successfully turned a travel router into a functional, headless Linux server.","tags":"TL-MR3020 HadrwareHacking DIY EmbeddedSytems Cyberdeck","title":"The 3020 Project: a TL-MR3020 Hacking continuation"},{"content":"I ‚Äì What is the WNH Initiative? The WNH Initiative, short for \u0026ldquo;Why Not Hardware,\u0026rdquo; is driven by the curiosity of its members, their desire to understand the world around them, and their passion for making it a better place by repurposing old hardware into something new. In doing so, it naturally addresses the ongoing e-waste crisis and inspires others to see value in devices that would otherwise be discarded.\nII ‚Äì How It Started Everything began with small experiments on an old TL-MR3020 router I found at home, exploring what could be done beyond its intended use (spoiler: it‚Äôs now my small portable IoT hub). What started as simple curiosity quickly turned into a mindset: instead of throwing hardware away, I ask, ‚ÄúWhat could it become?‚Äù With more upcoming projects and the positive feedback I received during NULLHat Morocco, I decided to expand its horizons and turn these experiments into a broader initiative.\nIII ‚Äì How It‚Äôs Going \u0026lt;|\u0026gt; Ongoing Projects TL-MR3020 : 3020Project\nThe TP-Link TL-MR3020 is a compact portable wireless router released in the early 2010s (around 2011‚Äì2013), designed to provide Wi-Fi connectivity, 3G/4G USB modem support, and basic routing functions in a highly portable form factor.\nIt is no longer commonly used today due to limited processing power, low memory, and outdated wireless standards compared to modern routers and mobile hotspots. \u0026lt;|\u0026gt; Upcoming babies upcoming projects feel free to suggest your ideas !! Casio pocket TV-1400\nThe Casio TV-1400 is a portable analog television produced in the late 1980s to early 1990s, designed to receive and display broadcast TV signals via an internal analog tuner and composite video circuitry. It features a compact display, basic tuning controls, and portable power options.\nToday, it is no longer widely used due to the global shutdown of analog TV broadcasting and the transition to digital television standards. daewoo dpc-7900PD\nThe Daewoo portable DVD player is a self-contained multimedia device produced in the mid-2000s (around 2005‚Äì2007), intended for portable DVD and media playback with an integrated TFT display, speakers, and battery.\nIt has largely fallen out of use due to the rise of smartphones, streaming services, and solid-state media, which offer more convenient, compact, and flexible video playback. \u0026lt;|\u0026gt; Members Taha Ed-dafili Me I ","date":"10 January, 2026","id":1,"permalink":"/WhyNot/posts/the-wnh-initiative/","summary":"The WNH Initiative, short for \u0026ldquo;Why Not Hardware,\u0026rdquo; is driven by the curiosity of its members, their desire to understand the world around them, and their passion for making it a better place by repurposing old hardware into something new. In doing so, it naturally addresses the ongoing e-waste crisis and inspires others to see value in devices that would otherwise be discarded.","tags":"repurposing DIY hardware","title":"The WNH Initiative: Idea \u0026 Vision"},{"content":"Debugging and Env Setup: RaspberryPi5Debugging rassbery-pi-debug-probe-datasheet ","date":"14 June, 2025","id":2,"permalink":"/WhyNot/posts/resources/raspberrypi5baremetal/","summary":"","tags":"resources docs arm","title":"Resources: bareMetal - Raspberry Pi 5"},{"content":"I - What\u0026rsquo;s the TL-MR3020? The TL-MR3020 is a small, portable wireless router made by TP-Link. Originally designed to share a 3G/4G USB modem connection over Wi-Fi, but we want more right ? It‚Äôs based on the Atheros AR9331 SoC, which includes: A 400 MHz MIPS processor 4 MB flash, 32 MB RAM USB 2.0 host support Despite its limited specs, the TL-MR3020 is incredibly capable with the right tweaks ‚Äî and that‚Äôs what this post is all about. II - What\u0026rsquo;s openWrt: OpenWrt is a lightweight Linux distribution designed specifically for embedded devices like routers. Unlike the stock firmware that comes preinstalled on most routers, OpenWrt gives you full control over your device ‚Äî with a package manager, writable filesystem, and the ability to run your own software.\nIII - Why Hack This Router? First and foremost ‚Äî why not? But on a serious note, hacking the TL-MR3020 breathes new life into an old piece of hardware and unlocks its full potential. Once you‚Äôve got OpenWrt running and serial access set up, you\u0026rsquo;re no longer limited by the stock firmware. On the contrary, you‚Äôll be encouraged to innovate and experiment with your own ideas, services, and projects. IV - Building a Custom OpenWrt Image As mentioned earlier, OpenWrt is a Linux distribution tailored for embedded devices. The latest supported version for the TL-MR3020 v1 is 17.01.7 (check hardware support).\nBy default, the official OpenWrt image comes with LuCI, the web interface ‚Äî but it consumes a significant amount of the router\u0026rsquo;s already limited memory.\n\u0026lt;|\u0026gt; TL-MR3020 With the official openWrt image: Out of the box, the router has only ~140 KB of free space left ‚Äî not enough to install the packages needed for EXT4 or USB storage support.\n\u0026lt;|\u0026gt; TL-MR3020 With our Custom Image: With a custom OpenWrt image, we can mount an external flash drive (e.g., a 64 GB USB) and use it as the main storage for packages and configuration files. This unlocks a ton of possibilities.\n\u0026lt;|\u0026gt; Download The image Builder: openWrt provide an image builder for you to make a custom image with your specific needs in mind (Download)\n\u0026lt;|\u0026gt; Build the image: Install any necessary dependencies on your system, then run:\nmake image PROFILE=tl-mr3020-v1 PACKAGES=\u0026#34;kmod-usb-core kmod-usb2 kmod-usb-storage kmod-fs-ext4 block-mount kmod-usb-storage-extras libblkid libuuid\u0026#34; Once the build finishes, the output will be located under:\nbin/targets/ar71xx/generic V - Flashing the OpenWrt Firmware \u0026lt;|\u0026gt; First-Time Flash: If this is your first time installing OpenWrt on the TL-MR3020, follow these steps:\nDownload the correct firmware\nUse the factory image:\nlede-17.01.7-ar71xx-generic-tl-mr3020-v1-squashfs-factory.bin\nConnect to the router\nPower on the router and connect to its default Wi-Fi network.\nOn the back of the router, you‚Äôll find details such as:\nDefault SSID Default IP (usually 192.168.0.1 or 192.168.1.1) Default username/password Access the web interface\nOpen a browser and go to the default IP address.\nLogin using the default credentials (often admin / admin or blank password).\nFlash the firmware\nNavigate to:\nSystem Tools \u0026gt; Firmware Upgrade\nUpload the .bin file you downloaded earlier.\nWait for the router to flash and reboot\nOnce the process finishes, the router will reboot into OpenWrt.\nNext Step: Connect via SSH\nAfter flashing, you\u0026rsquo;ll want to connect to your router via SSH.\n‚Üí See the Connecting to the Router via SSH section.\n\u0026lt;|\u0026gt; Updating to a New Version: If OpenWrt is already installed on your TL-MR3020:\nDownload the sysupgrade image\nGet this file:\nlede-17.01.7-ar71xx-generic-tl-mr3020-v1-squashfs-sysupgrade.bin\nConnect to the router\nSee How to Connect to the Router.\nHost the firmware on your PC\nInside the output folder on your host machine:\npython3 -m http.server 8000 Download the firmware to the router On the router (via SSH), run:\nwget http://\u0026lt;PC_IP\u0026gt;:8000/lede-17.01.7-ar71xx-generic-tl-mr3020-v1-squashfs-sysupgrade.bin -O /tmp/sysupgrade.bin (don\u0026rsquo;t forget to change \u0026lt;PC_IP\u0026gt; to your host computer IP)\nVerify the Download Check that the file size on the router matches the file on your PC.\nRun The Upgrade\nsysupgrade -n /tmp/sysupgrade.bin VI - Connecting to the Router via SSH Connect your router to your computer using an Ethernet cable. SSH into the router using: ssh -oHostKeyAlgorithms=+ssh-rsa -oPubkeyAcceptedKeyTypes=+ssh-rsa root@192.168.1.1 The router is usually configured to use 192.168.1.1 as its LAN interface IP. We force the use of RSA because the firmware is old and newer SSH clients may disable RSA by default. Voila! You\u0026rsquo;re in. You can now set an admin password or configure the system however you like. /// By now you may think you have everything you need to start all the awesome ideas you have in mind\u0026hellip; But:\nSo, let\u0026rsquo;s make that USB drive work for us!\nVII - Preparing a USB Drive Connect your USB drive to your computer.\nImportant: Before formatting, identify the correct device name for your USB drive to avoid data loss. Run:\nlsblk Look for your USB drive‚Äôs size and device path (e.g., /dev/sda1). Format the USB drive to use the EXT4 filesystem with:\nsudo mkfs.ext4 -O ^has_journal -m 0 -L \u0026lt;LABEL_NAME\u0026gt; /dev/sdX1 Replace /dev/sdX1 with the actual device name of your USB partition. Explanation of options:\n-O ^has_journal: disables journaling to reduce write wear and improve speed (less resilience to crashes). -m 0: reserves 0% space for root (normally 5% is reserved on Linux root disks, but not needed here). -L \u0026lt;LABEL_NAME\u0026gt;: sets a label name for the partition (replace \u0026lt;LABEL_NAME\u0026gt; with your desired label). VIII - Mounting the USB Drive on the Router Plug the USB drive into the router. check if the device is recognized: ls /dev/sda* You should see something like /dev/sda1. Create a mount point: mkdir /mnt/usb Mount the USB drive: mount /dev/sda1 /mnt/usb Navigate to the mounted directory: cd /mnt/usb Voila! You can now read from and write to your USB drive. IX - Making the USB the New Overlay (Storage Expansion via OverlayFS) By default, the router has only a few kilobytes of writable space. Let‚Äôs fix that by using a USB drive as the new overlay storage.\nEdit the fstab configuration: Open the file /etc/config/fstab and add the following: config mount option target \u0026#39;/overlay\u0026#39; option uuid \u0026#39;XXXXXXXXXX\u0026#39; # use block info to get your usb uuid option fstype \u0026#39;ext4\u0026#39; option options \u0026#39;noatime,nodiratime,data=writeback,barrier=0,commit=60\u0026#39; option enabled \u0026#39;1\u0026#39; option enabled_fsck \u0026#39;1\u0026#39; Get your USB‚Äôs UUID by running: block info Copy the current overlay to the USB: mount /dev/sda1 /mnt mount_root cd /overlay tar -cf - . | tar -C /mnt -xvf - umount /mnt This command tars the current overlay contents and extracts them onto the USB drive. ‚úÖ After reboot, OpenWrt will mount the USB as your overlay partition ‚Äî giving you way more room for packages and configuration! If something doesn\u0026rsquo;t work, try using:\ndmesg this shows the kernel debug messages \u0026ndash; useful for debugging USB or mount issues.\n(Optional) Adding Swap Space ‚ö†Ô∏è Backup your files ‚Äî you may lose data if something goes wrong.\nYou can add swap space to improve memory usage. Here\u0026rsquo;s how:\nCreate a new partition on your flash drive (e.g. 128MB) and set it as a Linux swap partition. Then, edit /etc/config/fstab and add the following section: config swap option device \u0026#39;/dev/sda2\u0026#39; option enabled \u0026#39;1\u0026#39; Reboot the router. Now you have 128MB of swap ‚Äî more than enough for most tasks! X - Setting Up the Serial Interface Setting up a serial interface gives you direct access to the router‚Äôs boot messages and console ‚Äî even if the firmware isn‚Äôt working correctly.\n\u0026lt;|\u0026gt; Why Use Serial? Unbrick your router if something goes wrong during a firmware flash. Debug kernel boot logs and system errors. Access the system when SSH or LuCI isn\u0026rsquo;t available. \u0026lt;|\u0026gt; Identifying the Serial Pins On the TL-MR3020 v1 board, you\u0026rsquo;ll spot a row of unpopulated holes near the edge ‚Äî that\u0026rsquo;s your UART/serial interface: Label Purpose VCC 3.3V (‚ö†Ô∏è Do NOT connect to USB-TTL VCC) TX Transmit RX Receive GND Ground ‚ö†Ô∏è Important: Only connect TX, RX, and GND. Do not connect VCC.\nüí° Tip: You can solder some male header pins in there to make future connections easier ‚Äî or just use jumper cables if you\u0026rsquo;re careful.\n\u0026lt;|\u0026gt; Connecting the Router to a USB-to-TTL Adapter If you don\u0026rsquo;t have an adapter, check the I Have No Adapter section. Connect the adapter to your PC. Wire the adapter to the TL-MR3020 board as follows: USB-TTL Adapter TL-MR3020 Board TX RX RX TX GND GND üîÑ TX goes to RX and RX goes to TX.\n\u0026lt;|\u0026gt; Using a Terminal Program You can use minicom, picocom, or screen to open a serial connection.\nExample with screen:\nscreen /dev/ttyUSB0 115200 üí°I Have No Adapter If you don‚Äôt have a USB-to-Serial adapter ‚Äî no worries! Just make one with what you already have.\nFor me, I had:\nAn Arduino Uno A Raspberry Pi Debug Probe \u0026lt;|\u0026gt; Method 1: Arduino Uno (or similar) Use the onboard USB-to-Serial chip of your Arduino.\nSteps: Connect Arduino via USB to PC\nWire like this:\nArduino Pin TL-MR3020 GND GND TX (D1) RX RX (D0) TX Connect RESET to GND on the Arduino.\nConnecting RESET to GND keeps the Arduino in a permanent reset state, which effectively disables the ATmega chip and allows the USB-to-Serial converter (like the CH340 or ATmega16U2) to communicate directly with the TL-MR3020.\n\u0026lt;|\u0026gt; Method 2: Using the Raspberry Pi Debug Probe If you have the Pi Debug Probe, just use its UART port.\nWire like this: debug Prob TL-MR3020 GND GND TX RX RX TX ‚ö†Ô∏è Make sure your connections use 3.3V logic! The TL-MR3020 is not 5V-tolerant.\n‚úÖ Bonus: The Debug Probe gives great signal stability and has built-in protection.\nNext Steps: Fun Projects You Can Do 1. Local Chat Server Host an IRC server (ngIRCd) on your TL-MR3020 and let friends connect using irssi or weechat. Great for: LAN parties Retro-feeling comms secure chat without needing internet And yep, all running off a tiny router with no internet required. 2. Host a Website (or Dashboard) spin up a tiny local web server using lighttpd or uhttpd host a personal dashboard, files, notes, or even a retro homepage make your own ‚Äúinternet-in-a-box‚Äù for offline use 3. Network Toolbox turn your TL-MR3020 into a Swiss Army knife for networking install tools like tcpdump, nmap, or iperf3 use it to: scan and monitor local networks test speeds and latency between devices debug network issues from anywhere, even without your laptop (you can just ssh from your phone üòâ 4. Just Go Wild You can literally do whatever you want :) It\u0026rsquo;s a Linux box ‚Äî automate stuff, make it blink LEDs, build a weather station, hack together weird networking tools, or just make it do cool nerdy stuff. Your tiny router, your rules.\n","date":"11 June, 2025","id":3,"permalink":"/WhyNot/posts/tl-mr3020-hacking/","summary":"","tags":"TL-MR3020 OpenWrt DIY EmbeddedLinux NetworkTools","title":"TL-MR3020 Hacking"}]